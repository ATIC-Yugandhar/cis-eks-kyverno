#!/usr/bin/env python3

import argparse
import os
import subprocess
import sys
import json
import time
from datetime import datetime

# Define base directories
BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
TERRAFORM_DIR = os.path.join(BASE_DIR, "terraform")
ENHANCED_DIR = os.path.join(TERRAFORM_DIR, "enhanced")
COMPLIANT_DIR = os.path.join(ENHANCED_DIR, "compliant")
NONCOMPLIANT_DIR = os.path.join(ENHANCED_DIR, "noncompliant")
REPORTS_DIR = os.path.join(BASE_DIR, "reports")
TESTS_DIR = os.path.join(BASE_DIR, "tests")

# Ensure all the necessary directories exist
os.makedirs(REPORTS_DIR, exist_ok=True)
os.makedirs(os.path.join(REPORTS_DIR, "compliance"), exist_ok=True)
os.makedirs(os.path.join(REPORTS_DIR, "comparison"), exist_ok=True)
os.makedirs(os.path.join(REPORTS_DIR, "metrics"), exist_ok=True)
os.makedirs(os.path.join(REPORTS_DIR, "dashboard"), exist_ok=True)

class Colors:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

def print_header(message):
    print(f"\n{Colors.HEADER}{Colors.BOLD}=== {message} ==={Colors.ENDC}\n")

def print_success(message):
    print(f"{Colors.OKGREEN}✓ {message}{Colors.ENDC}")

def print_warning(message):
    print(f"{Colors.WARNING}! {message}{Colors.ENDC}")

def print_error(message):
    print(f"{Colors.FAIL}✗ {message}{Colors.ENDC}")

def run_command(command, cwd=None, env=None):
    """Run a shell command and return the output"""
    print_warning(f"Running: {command}")
    try:
        result = subprocess.run(
            command,
            shell=True,
            check=True,
            text=True,
            capture_output=True,
            cwd=cwd,
            env=env
        )
        return result.stdout.strip()
    except subprocess.CalledProcessError as e:
        print_error(f"Command failed with exit code {e.returncode}")
        print(e.stderr)
        raise

def terraform_init(directory):
    """Run terraform init in the given directory"""
    print_header(f"Initializing Terraform in {directory}")
    run_command("terraform init", cwd=directory)
    print_success("Terraform initialized successfully")

def terraform_apply(directory, auto_approve=False):
    """Run terraform apply in the given directory"""
    print_header(f"Applying Terraform in {directory}")
    approve_flag = "-auto-approve" if auto_approve else ""
    run_command(f"terraform apply {approve_flag}", cwd=directory)
    print_success("Terraform applied successfully")

def terraform_destroy(directory, auto_approve=False):
    """Run terraform destroy in the given directory"""
    print_header(f"Destroying resources in {directory}")
    approve_flag = "-auto-approve" if auto_approve else ""
    run_command(f"terraform destroy {approve_flag}", cwd=directory)
    print_success("Resources destroyed successfully")

def get_kubeconfig(directory):
    """Get kubeconfig from terraform output"""
    print_header("Getting kubeconfig")
    output = run_command("terraform output -json kubeconfig", cwd=directory)
    kubeconfig = json.loads(output)
    return kubeconfig

def write_kubeconfig(directory, filename):
    """Write kubeconfig to a file"""
    kubeconfig = get_kubeconfig(directory)
    kubeconfig_path = os.path.join(BASE_DIR, filename)
    
    with open(kubeconfig_path, "w") as f:
        f.write(kubeconfig)
    
    print_success(f"Kubeconfig written to {kubeconfig_path}")
    return kubeconfig_path

def run_tests(kubeconfig_path, test_patterns=None):
    """Run kyverno tests using the kubeconfig"""
    print_header("Running tests")
    
    env = os.environ.copy()
    env["KUBECONFIG"] = kubeconfig_path
    
    if test_patterns:
        for pattern in test_patterns:
            test_dirs = [os.path.join(TESTS_DIR, d) for d in os.listdir(TESTS_DIR) 
                        if os.path.isdir(os.path.join(TESTS_DIR, d)) and pattern in d]
            
            for test_dir in test_dirs:
                test_name = os.path.basename(test_dir)
                print_warning(f"Running test: {test_name}")
                
                compliant_dir = os.path.join(test_dir, "compliant")
                noncompliant_dir = os.path.join(test_dir, "noncompliant")
                
                if os.path.exists(compliant_dir):
                    test_file = os.path.join(compliant_dir, "kyverno-test.yaml")
                    if os.path.exists(test_file):
                        run_command(f"kubectl kyverno test {test_file}", env=env)
                
                if os.path.exists(noncompliant_dir):
                    test_file = os.path.join(noncompliant_dir, "kyverno-test.yaml")
                    if os.path.exists(test_file):
                        run_command(f"kubectl kyverno test {test_file}", env=env)
    else:
        # Run all tests
        run_command(f"{BASE_DIR}/scripts/test-all-policies.sh", env=env)
    
    print_success("Tests completed")

def generate_report(compliant_kubeconfig=None, noncompliant_kubeconfig=None, output_formats=None):
    """Generate compliance reports"""
    print_header("Generating reports")
    
    timestamp = datetime.now().strftime("%Y%m%d-%H%M%S")
    
    formats = output_formats.split(",") if output_formats else ["markdown"]
    
    # Generate compliance reports for each cluster
    if compliant_kubeconfig:
        for fmt in formats:
            report_path = os.path.join(REPORTS_DIR, "compliance", f"compliant-cluster-{timestamp}.{fmt}")
            print_warning(f"Generating compliant cluster report in {fmt} format")
            # In a real implementation, this would call a reporting function
            with open(report_path, "w") as f:
                f.write(f"# Compliant Cluster Compliance Report\n\nGenerated: {timestamp}\n\n")
                f.write("This is a placeholder for the actual compliance report.\n")
    
    if noncompliant_kubeconfig:
        for fmt in formats:
            report_path = os.path.join(REPORTS_DIR, "compliance", f"noncompliant-cluster-{timestamp}.{fmt}")
            print_warning(f"Generating non-compliant cluster report in {fmt} format")
            # In a real implementation, this would call a reporting function
            with open(report_path, "w") as f:
                f.write(f"# Non-Compliant Cluster Compliance Report\n\nGenerated: {timestamp}\n\n")
                f.write("This is a placeholder for the actual compliance report.\n")
    
    # Generate comparison report if both configs are provided
    if compliant_kubeconfig and noncompliant_kubeconfig:
        for fmt in formats:
            report_path = os.path.join(REPORTS_DIR, "comparison", f"cluster-comparison-{timestamp}.{fmt}")
            print_warning(f"Generating comparison report in {fmt} format")
            # In a real implementation, this would call a reporting function
            with open(report_path, "w") as f:
                f.write(f"# Cluster Compliance Comparison\n\nGenerated: {timestamp}\n\n")
                f.write("This is a placeholder for the actual comparison report.\n")
    
    print_success("Reports generated successfully")
    return os.path.join(REPORTS_DIR, "compliance")

def setup_clusters(compliant=False, noncompliant=False, auto_approve=False):
    """Set up the specified clusters"""
    if compliant:
        terraform_init(COMPLIANT_DIR)
        terraform_apply(COMPLIANT_DIR, auto_approve)
        write_kubeconfig(COMPLIANT_DIR, "kubeconfig-compliant")
    
    if noncompliant:
        terraform_init(NONCOMPLIANT_DIR)
        terraform_apply(NONCOMPLIANT_DIR, auto_approve)
        write_kubeconfig(NONCOMPLIANT_DIR, "kubeconfig-noncompliant")

def cleanup_clusters(compliant=False, noncompliant=False, auto_approve=False):
    """Clean up the specified clusters"""
    if compliant:
        terraform_destroy(COMPLIANT_DIR, auto_approve)
    
    if noncompliant:
        terraform_destroy(NONCOMPLIANT_DIR, auto_approve)

def main():
    parser = argparse.ArgumentParser(
        description="EKS Kyverno Testing Tool",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Deploy both cluster types and run all tests
  eks-kyverno-test run-all

  # Deploy only compliant cluster and run specific tests
  eks-kyverno-test run --cluster-type compliant --tests cis-3.2.1,cis-4.1.1

  # Run tests against existing clusters
  eks-kyverno-test test --compliant-kubeconfig ~/kubeconfig-compliant \\
                        --noncompliant-kubeconfig ~/kubeconfig-noncompliant

  # Generate comprehensive compliance report
  eks-kyverno-test report --output-format html,json,markdown

  # Clean up resources
  eks-kyverno-test cleanup
        """
    )
    
    subparsers = parser.add_subparsers(dest="command", help="Command to run")
    
    # Setup command
    setup_parser = subparsers.add_parser("setup", help="Set up clusters without running tests")
    setup_parser.add_argument("--cluster-type", choices=["compliant", "noncompliant", "both"], default="both",
                              help="Which cluster type to set up")
    setup_parser.add_argument("--auto-approve", action="store_true", help="Skip approval prompt for Terraform operations")
    
    # Run command
    run_parser = subparsers.add_parser("run", help="Set up clusters and run tests")
    run_parser.add_argument("--cluster-type", choices=["compliant", "noncompliant", "both"], default="both",
                            help="Which cluster type to run tests on")
    run_parser.add_argument("--tests", help="Comma-separated list of test patterns to run")
    run_parser.add_argument("--auto-approve", action="store_true", help="Skip approval prompt for Terraform operations")
    
    # Run-all command (convenience shortcut)
    subparsers.add_parser("run-all", help="Set up both cluster types and run all tests")
    
    # Test command
    test_parser = subparsers.add_parser("test", help="Run tests against existing clusters")
    test_parser.add_argument("--compliant-kubeconfig", help="Path to kubeconfig for compliant cluster")
    test_parser.add_argument("--noncompliant-kubeconfig", help="Path to kubeconfig for non-compliant cluster")
    test_parser.add_argument("--tests", help="Comma-separated list of test patterns to run")
    
    # Report command
    report_parser = subparsers.add_parser("report", help="Generate compliance reports")
    report_parser.add_argument("--compliant-kubeconfig", help="Path to kubeconfig for compliant cluster")
    report_parser.add_argument("--noncompliant-kubeconfig", help="Path to kubeconfig for non-compliant cluster")
    report_parser.add_argument("--output-format", default="markdown", help="Comma-separated list of output formats (markdown,html,json)")
    
    # Cleanup command
    cleanup_parser = subparsers.add_parser("cleanup", help="Clean up resources")
    cleanup_parser.add_argument("--cluster-type", choices=["compliant", "noncompliant", "both"], default="both",
                                help="Which cluster type to clean up")
    cleanup_parser.add_argument("--auto-approve", action="store_true", help="Skip approval prompt for Terraform operations")
    
    args = parser.parse_args()
    
    if not args.command:
        parser.print_help()
        sys.exit(1)
    
    if args.command == "setup":
        setup_clusters(
            compliant=(args.cluster_type in ["compliant", "both"]),
            noncompliant=(args.cluster_type in ["noncompliant", "both"]),
            auto_approve=args.auto_approve
        )
    
    elif args.command == "run":
        # Set up clusters
        setup_clusters(
            compliant=(args.cluster_type in ["compliant", "both"]),
            noncompliant=(args.cluster_type in ["noncompliant", "both"]),
            auto_approve=args.auto_approve
        )
        
        # Run tests
        if args.cluster_type in ["compliant", "both"]:
            kubeconfig_path = os.path.join(BASE_DIR, "kubeconfig-compliant")
            test_patterns = args.tests.split(",") if args.tests else None
            run_tests(kubeconfig_path, test_patterns)
        
        if args.cluster_type in ["noncompliant", "both"]:
            kubeconfig_path = os.path.join(BASE_DIR, "kubeconfig-noncompliant")
            test_patterns = args.tests.split(",") if args.tests else None
            run_tests(kubeconfig_path, test_patterns)
    
    elif args.command == "run-all":
        # Set up both clusters
        setup_clusters(compliant=True, noncompliant=True, auto_approve=True)
        
        # Run all tests on both clusters
        run_tests(os.path.join(BASE_DIR, "kubeconfig-compliant"))
        run_tests(os.path.join(BASE_DIR, "kubeconfig-noncompliant"))
        
        # Generate reports
        generate_report(
            compliant_kubeconfig=os.path.join(BASE_DIR, "kubeconfig-compliant"),
            noncompliant_kubeconfig=os.path.join(BASE_DIR, "kubeconfig-noncompliant"),
            output_formats="markdown,html,json"
        )
    
    elif args.command == "test":
        # Run tests on existing clusters
        if args.compliant_kubeconfig:
            test_patterns = args.tests.split(",") if args.tests else None
            run_tests(args.compliant_kubeconfig, test_patterns)
        
        if args.noncompliant_kubeconfig:
            test_patterns = args.tests.split(",") if args.tests else None
            run_tests(args.noncompliant_kubeconfig, test_patterns)
    
    elif args.command == "report":
        # Generate reports for existing clusters
        report_dir = generate_report(
            compliant_kubeconfig=args.compliant_kubeconfig,
            noncompliant_kubeconfig=args.noncompliant_kubeconfig,
            output_formats=args.output_format
        )
        print_success(f"Reports saved to {report_dir}")
    
    elif args.command == "cleanup":
        # Clean up resources
        cleanup_clusters(
            compliant=(args.cluster_type in ["compliant", "both"]),
            noncompliant=(args.cluster_type in ["noncompliant", "both"]),
            auto_approve=args.auto_approve
        )

if __name__ == "__main__":
    main()